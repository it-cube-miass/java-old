# 3.4 Целочисленные типы

Особенности типа _char_ мы рассмотрели в предыдущей статье. Здесь же мы рассмотрим все целочисленные примитивные типы Java оптом, так как они отличаются друг от друга только размером, а следовательно, только максимальным и минимальным значениями, которые могут содержать. Все типы за исключением _char_ являются знаковыми, _char_, как уже объяснялось беззнаковый. Повторим таблицу размеров и значений для этих типов еще раз:

| Тип | Содержит | По умолчанию | Размер | Диапазон | Класс обертка |
| :--- | :--- | :--- | :--- | :--- | :--- |
| char | целое беззнаковое | \u0000 | 16 бит | от \u0000  до \uFFFF \(от 0 до 65535 десятичное\) | Character |
| byte | целое знаковое | 0 | 8 бит | от -128 до 127 | Byte |
| short | целое знаковое | 0 | 16 бит | от -32768 до 32767 | Short |
| int | целое знаковое | 0 | 32 бита | от -2147483648 до 2147483647 | Integer |
| long | целое знаковое | 0 | 64 бита | от -9223372036854775808 до 9223372036854775807 | Long |

## Целочисленные литералы

Значения целочисленным переменным и константам задаются при помощи следующих литералов:

* `108` – десятичный литерал
* `0154` – восьмеричный литерал \(в начале стоит ноль\)
* `0x6c` – шестнадцатеричный литерал
* `0b01101100` – двоичный литерал

Так же в числовых литералах можно использовать символ подчеркивания \_ для разграничения разрядов, это сделано только для удобства написания и понимания и ни как не влияет на значение.

```java
int i = 1_000;
```

Для обозначения литерала типа _long_ можно использовать суффикс `L` или `l` \(маленькую `l` легко cпутать с единицей `1`, поэтому предпочтительнее `L`\).

```java
long value = 3_000_000_000L;
```

Eсть один интересный момент, что переменной типа _long_ невозможно задать значения больше `2147483647` следующим оператором присваивания:

```java
long value = 2147483648;
```

Хотя значение `2147483648` является допустимым для типа _long_, но компилятор считает число `2147483648` литералом типа _int_, поскольку у него нет суффикса `L`, а для типа _int_ число `2147483648` является не допустимым значением и поэтому компилятор выдаст ошибку. Чтобы этого не было надо использовать суффикс L.

```java
long value = 2147483648L;
```

Над целочисленными типами можно совершать различные операции при помощи операторов сравнения, математических операторов и операторов побитового сдвига.

Операции сравнения для примитивных типов сравнивают их значения.  
Операторы сравнения мы уже рассматривали при изучении типа _boolean_. Результатом этих операций может быть только значение типа _boolean_.

## Арифметические операции

* `+`  сложение
* `-`  вычитание
* `*`  умножение
* `/`  деление
* `%`  остаток от деления
* `++`  инкремент
* `--`  декремент

Тут впрочем все просто. На что только надо обратить внимание, это то, что деление над целочисленными типами тоже целочисленное.

```java
int value =  5 / 3; // value = 1;
```

Инкремент и декремент \(увеличение или уменьшение на единицу\) может быть как префиксным, так и постфиксным.

```java
int count = 10;
count++; // постфиксный
++count; // префиксный
```

При использовании префиксного оператора сперва происходит инкремент или декремент переменной, а затем используется ее значение.

```java
int i = 10;
int a = ++i;

System.out.println(i); // 11
System.out.println(a); // 11
```

При постфиксной наоборот – сперва используется текущее значение переменной, а затем происходит ее декремент или инкремент.

```java
int i = 10;
int a = i++;

System.out.println(i); // 11
System.out.println(a); // 10
```

Стоит упомянуть, что при делении на ноль возникает исключительная ситуация _ArithmeticException_, которая при отсутствии её обработки приводит к аварийному завершению работы программы.

Переполнение же не является исключительной ситуацией, лишние старшие биты просто выкидываются.

Операция деление по модулю \(или остаток\) определяется так:  
`a % b = a — (a / b) * b`  
То есть 5%3=2, потому что 5-\(5/3\)\*3=2

И еще стоит упомянуть об унарном операторе минус `−`. Если `−` используется как унарный оператор перед отдельным операндом, он выполняет унарную инверсию знака. Другими словами, он переводит положительное значение в эквивалентное ему отрицательное, и наоборот.

