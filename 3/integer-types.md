Особенности типа *char* мы рассмотрели в предыдущей статье. Здесь же мы рассмотрим все целочисленные примитивные типы Java оптом, так как они отличаются друг от друга только размером, а следовательно, только максимальным и минимальным значениями, которые могут содержать. Все типы за исключением *char* являются знаковыми, *char*, как уже объяснялось беззнаковый. Повторим таблицу размеров и значений для этих типов еще раз:

| Тип     |   Содержит          |   По умолчанию |   Размер  |   Диапазон                                        |   Класс обертка |
|---------|---------------------|----------------|-----------|---------------------------------------------------|-----------------|
|   char  |   целое беззнаковое |   \u0000       |   16 бит  |   от \u0000  до \uFFFF (от 0 до 65535 десятичное) |   Character     |
|   byte  |   целое знаковое    |   0            |   8 бит   |   от -128 до 127                                  |   Byte          |
|   short |   целое знаковое    |   0            |   16 бит  |   от -32768 до 32767                              |   Short         |
|   int   |   целое знаковое    |   0            |   32 бита |   от -2147483648 до 2147483647                    |   Integer       |
|   long  |   целое знаковое    |   0            |   64 бита |   от -9223372036854775808 до 9223372036854775807  |   Long          |

## Целочисленные литералы
Значения целочисленным переменным и константам задаются при помощи следующих литералов:

- ```108``` – десятичный литерал
- ```0154``` – восьмеричный литерал (в начале стоит ноль)
- ```0x6c``` – шестнадцатеричный литерал
- ```0b01101100``` – двоичный литерал

Так же в числовых литералах можно использовать символ подчеркивания _ для разграничения разрядов, это сделано только для удобства написания и понимания и ни как не влияет на значение. 
```java
int i = 1_000;
```
Для обозначения литерала типа *long* можно использовать суффикс ```L``` или ```l``` (маленькую ```l``` легко cпутать с единицей ```1```, поэтому предпочтительнее ```L```).
```java
long value = 3_000_000_000L;
```
Eсть один интересный момент, что переменной типа *long* невозможно задать значения больше ```2147483647``` следующим оператором присваивания:
```java
long value = 2147483648;
```
Хотя значение ```2147483648``` является допустимым для типа *long*, но компилятор считает число ```2147483648``` литералом типа *int*, поскольку у него нет суффикса ```L```, а для типа *int* число ```2147483648``` является не допустимым значением и поэтому компилятор выдаст ошибку. Чтобы этого не было надо использовать суффикс L.
```java
long value = 2147483648L;
```

Над целочисленными типами можно совершать различные операции при помощи операторов сравнения, математических операторов и операторов побитового сдвига.

Операции сравнения для примитивных типов сравнивают их значения.  
Операторы сравнения мы уже рассматривали при изучении типа *boolean*. Результатом этих операций может быть только значение типа *boolean*.

## Арифметические операции
- ```+```  сложение
- ```-```  вычитание
- ```*```  умножение
- ```/```  деление
- ```%```  остаток от деления
- ```++```  инкремент
- ```--```  декремент

Тут впрочем все просто. На что только надо обратить внимание, это то, что деление над целочисленными типами тоже целочисленное.
```java
int value =  5 / 3; // value = 1;
```
Инкремент и декремент (увеличение или уменьшение на единицу) может быть как префиксным, так и постфиксным. 
```java
int count = 10;
count++; // постфиксный
++count; // префиксный
```
При использовании префиксного оператора сперва происходит инкремент или декремент переменной, а затем используется ее значение.
```java
int i = 10;
int a = ++i;

System.out.println(i); // 11
System.out.println(a); // 11
```
При постфиксной наоборот – сперва используется текущее значение переменной, а затем происходит ее декремент или инкремент.
```java
int i = 10;
int a = i++;

System.out.println(i); // 11
System.out.println(a); // 10
```

Стоит упомянуть, что при делении на ноль возникает исключительная ситуация *ArithmeticException*, которая при отсутствии её обработки приводит к аварийному завершению работы программы.

Переполнение же не является исключительной ситуацией, лишние старшие биты просто выкидываются.

Операция деление по модулю (или остаток) определяется так:  
```a % b = a — (a / b) * b```  
То есть 5%3=2, потому что 5-(5/3)*3=2

И еще стоит упомянуть об унарном операторе минус ```−```. Если ```−``` используется как унарный оператор перед отдельным операндом, он выполняет унарную инверсию знака. Другими словами, он переводит положительное значение в эквивалентное ему отрицательное, и наоборот.
